// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# **Core API**
# 
# Provides access to the core features of Alfresco Content Services.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "/alfresco/api/-default-/public/alfresco/versions/1") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List comments
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/comments(map<string|string[]> headers = {}, *ListCommentsQueries queries) returns CommentPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a comment
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The comment text. Note that you can also provide a list of comments 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/comments(CommentBody payload, map<string|string[]> headers = {}, *CreateCommentQueries queries) returns CommentEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update a comment
    #
    # + nodeId - The identifier of a node
    # + commentId - The identifier of a comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The JSON representing the comment to be updated 
    # + return - Successful response 
    resource isolated function put nodes/[string nodeId]/comments/[string commentId](CommentBody payload, map<string|string[]> headers = {}, *UpdateCommentQueries queries) returns CommentEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments/${getEncodedUri(commentId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a comment
    #
    # + nodeId - The identifier of a node
    # + commentId - The identifier of a comment
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/comments/[string commentId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments/${getEncodedUri(commentId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List ratings
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/ratings(map<string|string[]> headers = {}, *ListRatingsQueries queries) returns RatingPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a rating
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - For "myRating" the type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/ratings(RatingBody payload, map<string|string[]> headers = {}, *CreateRatingQueries queries) returns RatingEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a rating
    #
    # + nodeId - The identifier of a node
    # + ratingId - The identifier of a rating
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/ratings/[string ratingId](map<string|string[]> headers = {}, *GetRatingQueries queries) returns RatingEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings/${getEncodedUri(ratingId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a rating
    #
    # + nodeId - The identifier of a node
    # + ratingId - The identifier of a rating
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/ratings/[string ratingId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings/${getEncodedUri(ratingId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List tags for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/tags(map<string|string[]> headers = {}, *ListTagsForNodeQueries queries) returns TagPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a tag for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new tag 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/tags(TagBody payload, map<string|string[]> headers = {}, *CreateTagForNodeQueries queries) returns TagEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete a tag from a node
    #
    # + nodeId - The identifier of a node
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/tags/[string tagId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags/${getEncodedUri(tagId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a node
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId](map<string|string[]> headers = {}, *GetNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The node information to update 
    # + return - Successful response 
    resource isolated function put nodes/[string nodeId](NodeBodyUpdate payload, map<string|string[]> headers = {}, *UpdateNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId](map<string|string[]> headers = {}, *DeleteNodeQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List node children
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/children(map<string|string[]> headers = {}, *ListNodeChildrenQueries queries) returns NodeChildAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/children`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a node
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The node information to create 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/children(NodeBodyCreate payload, map<string|string[]> headers = {}, *CreateNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/children`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Copy a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId and, optionally, a new name which should include the file extension 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/copy(NodeBodyCopy payload, map<string|string[]> headers = {}, *CopyNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/copy`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Lock a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Lock details 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/'lock(NodeBodyLock payload, map<string|string[]> headers = {}, *LockNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/lock`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unlock a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/unlock(map<string|string[]> headers = {}, *UnlockNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/unlock`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Move a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId and, optionally, a new name which should include the file extension 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/move(NodeBodyMove payload, map<string|string[]> headers = {}, *MoveNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/move`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/content(GetNodeContentHeaders headers = {}, *GetNodeContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The binary content 
    # + return - Successful response 
    resource isolated function put nodes/[string nodeId]/content(byte[] payload, map<string|string[]> headers = {}, *UpdateNodeContentQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/content`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List renditions
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/renditions(map<string|string[]> headers = {}, *ListRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create rendition
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + payload - The rendition "id" 
    # + return - Request accepted 
    resource isolated function post nodes/[string nodeId]/renditions(RenditionBodyCreate payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get rendition information
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/renditions/[string renditionId](map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/renditions/[string renditionId]/content(GetRenditionContentHeaders headers = {}, *GetRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List secondary children
    #
    # + nodeId - The identifier of a parent node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/secondary\-children(map<string|string[]> headers = {}, *ListSecondaryChildrenQueries queries) returns NodeChildAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create secondary child
    #
    # + nodeId - The identifier of a parent node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The child node id and assoc type 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/secondary\-children(ChildAssociationBody payload, map<string|string[]> headers = {}, *CreateSecondaryChildAssociationQueries queries) returns ChildAssociationEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete secondary child or children
    #
    # + nodeId - The identifier of a parent node
    # + childId - The identifier of a child node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/secondary\-children/[string childId](map<string|string[]> headers = {}, *DeleteSecondaryChildAssociationQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children/${getEncodedUri(childId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List parents
    #
    # + nodeId - The identifier of a child node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/parents(map<string|string[]> headers = {}, *ListParentsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/parents`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List target associations
    #
    # + nodeId - The identifier of a source node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/targets(map<string|string[]> headers = {}, *ListTargetAssociationsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create node association
    #
    # + nodeId - The identifier of a source node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The target node id and assoc type 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/targets(AssociationBody payload, map<string|string[]> headers = {}, *CreateAssociationQueries queries) returns AssociationEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete node association(s)
    #
    # + nodeId - The identifier of a source node
    # + targetId - The identifier of a target node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/targets/[string targetId](map<string|string[]> headers = {}, *DeleteAssociationQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets/${getEncodedUri(targetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List source associations
    #
    # + nodeId - The identifier of a target node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/sources(map<string|string[]> headers = {}, *ListSourceAssociationsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/sources`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List version history
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions(map<string|string[]> headers = {}, *ListVersionHistoryQueries queries) returns VersionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get version information
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions/[string versionId](map<string|string[]> headers = {}) returns VersionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete nodes/[string nodeId]/versions/[string versionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get version content
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions/[string versionId]/content(GetVersionContentHeaders headers = {}, *GetVersionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Revert a version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Optionally, specify a version comment and whether this should be a major version, or not 
    # + return - Successful response 
    resource isolated function post nodes/[string nodeId]/versions/[string versionId]/revert(RevertBody payload, map<string|string[]> headers = {}, *RevertVersionQueries queries) returns VersionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/revert`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List renditions for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions/[string versionId]/renditions(map<string|string[]> headers = {}, *ListVersionRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create rendition for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + payload - The rendition "id" 
    # + return - Request accepted 
    resource isolated function post nodes/[string nodeId]/versions/[string versionId]/renditions(RenditionBodyCreate payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get rendition information for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions/[string versionId]/renditions/[string renditionId](map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/versions/[string versionId]/renditions/[string renditionId]/content(GetVersionRenditionContentHeaders headers = {}, *GetVersionRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieve actions for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Unexpected error 
    resource isolated function get nodes/[string nodeId]/action\-definitions(map<string|string[]> headers = {}, *NodeActionsQueries queries) returns ActionDefinitionList|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/action-definitions`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List deleted nodes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes(map<string|string[]> headers = {}, *ListDeletedNodesQueries queries) returns DeletedNodesPaging|error {
        string resourcePath = string `/deleted-nodes`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes/[string nodeId](map<string|string[]> headers = {}, *GetDeletedNodeQueries queries) returns DeletedNodeEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete deleted\-nodes/[string nodeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get deleted node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes/[string nodeId]/content(GetDeletedNodeContentHeaders headers = {}, *GetDeletedNodeContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Restore a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId if the node is restored to a new location 
    # + return - Successful response 
    resource isolated function post deleted\-nodes/[string nodeId]/restore(DeletedNodeBodyRestore payload, map<string|string[]> headers = {}, *RestoreDeletedNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/restore`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List renditions for a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes/[string nodeId]/renditions(map<string|string[]> headers = {}, *ListDeletedNodeRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition information for a deleted node
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes/[string nodeId]/renditions/[string renditionId](map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content of a deleted node
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get deleted\-nodes/[string nodeId]/renditions/[string renditionId]/content(GetArchivedNodeRenditionContentHeaders headers = {}, *GetArchivedNodeRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a new download
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The nodeIds the content of which will be zipped, which zip will be set as the content of our download node 
    # + return - The request to create a download node was accepted 
    resource isolated function post downloads(DownloadBodyCreate payload, map<string|string[]> headers = {}, *CreateDownloadQueries queries) returns DownloadEntry|error {
        string resourcePath = string `/downloads`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a download
    #
    # + downloadId - The identifier of a download node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Download node information 
    resource isolated function get downloads/[string downloadId](map<string|string[]> headers = {}, *GetDownloadQueries queries) returns DownloadEntry|error {
        string resourcePath = string `/downloads/${getEncodedUri(downloadId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Cancel a download
    #
    # + downloadId - The identifier of a download node
    # + headers - Headers to be sent with the request 
    # + return - The request to cancel a download was accepted 
    resource isolated function delete downloads/[string downloadId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/downloads/${getEncodedUri(downloadId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List people
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people(map<string|string[]> headers = {}, *ListPeopleQueries queries) returns PersonPaging|error {
        string resourcePath = string `/people`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create person
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person details 
    # + return - Successful response 
    resource isolated function post people(PersonBodyCreate payload, map<string|string[]> headers = {}, *CreatePersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a person
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId](map<string|string[]> headers = {}, *GetPersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update person
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person details 
    # + return - Successful response 
    resource isolated function put people/[string personId](PersonBodyUpdate payload, map<string|string[]> headers = {}, *UpdatePersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List activities
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/activities(map<string|string[]> headers = {}, *ListActivitiesForPersonQueries queries) returns ActivityPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/activities`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List favorite sites
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get people/[string personId]/favorite\-sites(map<string|string[]> headers = {}, *ListFavoriteSitesForPersonQueries queries) returns SitePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site favorite
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The id of the site to favorite 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post people/[string personId]/favorite\-sites(FavoriteSiteBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteFavoriteQueries queries) returns FavoriteSiteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/favorite\-sites/[string siteId](map<string|string[]> headers = {}, *GetFavoriteSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete people/[string personId]/favorite\-sites/[string siteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List favorites
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/favorites(map<string|string[]> headers = {}, *ListFavoritesQueries queries) returns FavoritePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a favorite
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - An object identifying the entity to be favorited 
    # + return - Successful response 
    resource isolated function post people/[string personId]/favorites(FavoriteBodyCreate payload, map<string|string[]> headers = {}, *CreateFavoriteQueries queries) returns FavoriteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a favorite
    #
    # + personId - The identifier of a person
    # + favoriteId - The identifier of a favorite
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/favorites/[string favoriteId](map<string|string[]> headers = {}, *GetFavoriteQueries queries) returns FavoriteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites/${getEncodedUri(favoriteId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a favorite
    #
    # + personId - The identifier of a person
    # + favoriteId - The identifier of a favorite
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete people/[string personId]/favorites/[string favoriteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites/${getEncodedUri(favoriteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List network membership
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/networks(map<string|string[]> headers = {}, *ListNetworksForPersonQueries queries) returns PersonNetworkPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/networks`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get network information
    #
    # + personId - The identifier of a person
    # + networkId - The identifier of a network
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/networks/[string networkId](map<string|string[]> headers = {}, *GetNetworkForPersonQueries queries) returns PersonNetworkEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/networks/${getEncodedUri(networkId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List preferences
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/preferences(map<string|string[]> headers = {}, *ListPreferencesQueries queries) returns PreferencePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/preferences`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a preference
    #
    # + personId - The identifier of a person
    # + preferenceName - The name of the preference
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/preferences/[string preferenceName](map<string|string[]> headers = {}, *GetPreferenceQueries queries) returns PreferenceEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/preferences/${getEncodedUri(preferenceName)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List site membership requests
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/site\-membership\-requests(map<string|string[]> headers = {}, *ListSiteMembershipRequestsForPersonQueries queries) returns SiteMembershipRequestPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership request
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Site membership request details 
    # + return - Successful response 
    resource isolated function post people/[string personId]/site\-membership\-requests(SiteMembershipRequestBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/site\-membership\-requests/[string siteId](map<string|string[]> headers = {}, *GetSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new message to display 
    # + return - Successful response 
    resource isolated function put people/[string personId]/site\-membership\-requests/[string siteId](SiteMembershipRequestBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete people/[string personId]/site\-membership\-requests/[string siteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List site memberships
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/sites(map<string|string[]> headers = {}, *ListSiteMembershipsForPersonQueries queries) returns SiteRolePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a site membership
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/sites/[string siteId](map<string|string[]> headers = {}) returns SiteRoleEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites/${getEncodedUri(siteId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a site membership
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete people/[string personId]/sites/[string siteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List group memberships
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/groups(map<string|string[]> headers = {}, *ListGroupMembershipsForPersonQueries queries) returns GroupPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/groups`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Request password reset
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The client name to send email with app-specific url 
    # + return - Successful response or even when the **personId** does not exist or the user is disabled by an Administrator 
    resource isolated function post people/[string personId]/request\-password\-reset(ClientBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/request-password-reset`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reset password
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The reset password details 
    # + return - Successful response or even when no workflow instance is found with the given **id** or the workflow instance is invalid (already been used or expired) or the given **personId** does not match the person's id requesting the password reset or the given workflow **key** does not match the recovered key 
    resource isolated function post people/[string personId]/reset\-password(PasswordResetBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/reset-password`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get people/[string personId]/avatar(GetAvatarImageHeaders headers = {}, *GetAvatarImageQueries queries) returns byte[]|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The binary content 
    # + return - Successful response 
    resource isolated function put people/[string personId]/avatar(byte[] payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete people/[string personId]/avatar(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List sites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites(map<string|string[]> headers = {}, *ListSitesQueries queries) returns SitePaging|error {
        string resourcePath = string `/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The site details 
    # + return - Successful response 
    resource isolated function post sites(SiteBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId](map<string|string[]> headers = {}, *GetSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The site information to update 
    # + return - Successful response 
    resource isolated function put sites/[string siteId](SiteBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete sites/[string siteId](map<string|string[]> headers = {}, *DeleteSiteQueries queries) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List site containers
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/containers(map<string|string[]> headers = {}, *ListSiteContainersQueries queries) returns SiteContainerPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/containers`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a site container
    #
    # + siteId - The identifier of a site
    # + containerId - The unique identifier of a site container
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/containers/[string containerId](map<string|string[]> headers = {}, *GetSiteContainerQueries queries) returns SiteContainerEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/containers/${getEncodedUri(containerId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get site membership requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get site\-membership\-requests(map<string|string[]> headers = {}, *GetSiteMembershipRequestsQueries queries) returns SiteMembershipRequestWithPersonPaging|error {
        string resourcePath = string `/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Approve a site membership request
    #
    # + siteId - The identifier of a site
    # + inviteeId - The invitee user name
    # + headers - Headers to be sent with the request 
    # + payload - Accepting a request to join, optionally, allows assignment of a role to the user 
    # + return - Successful response 
    resource isolated function post sites/[string siteId]/site\-membership\-requests/[string inviteeId]/approve(SiteMembershipApprovalBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/site-membership-requests/${getEncodedUri(inviteeId)}/approve`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reject a site membership request
    #
    # + siteId - The identifier of a site
    # + inviteeId - The invitee user name
    # + headers - Headers to be sent with the request 
    # + payload - Rejecting a request to join, optionally, allows the inclusion of comment 
    # + return - Successful response 
    resource isolated function post sites/[string siteId]/site\-membership\-requests/[string inviteeId]/reject(SiteMembershipRejectionBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/site-membership-requests/${getEncodedUri(inviteeId)}/reject`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List site memberships
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/members(map<string|string[]> headers = {}, *ListSiteMembershipsQueries queries) returns SiteMemberPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person to add and their role 
    # + return - Successful response 
    resource isolated function post sites/[string siteId]/members(SiteMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/members/[string personId](map<string|string[]> headers = {}, *GetSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The persons new role 
    # + return - Successful response 
    resource isolated function put sites/[string siteId]/members/[string personId](SiteMembershipBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete sites/[string siteId]/members/[string personId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List group membership for site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/group\-members(map<string|string[]> headers = {}, *ListSiteGroupsQueries queries) returns SiteGroupPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership for group
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group to add and their role 
    # + return - Successful response 
    resource isolated function post sites/[string siteId]/group\-members(SiteMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get information about site membership of group
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get sites/[string siteId]/group\-members/[string groupId](map<string|string[]> headers = {}, *GetSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update site membership of group
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The groupId new role 
    # + return - Successful response 
    resource isolated function put sites/[string siteId]/group\-members/[string groupId](SiteMembershipBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a group membership for site
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete sites/[string siteId]/group\-members/[string groupId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List tags
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get tags(map<string|string[]> headers = {}, *ListTagsQueries queries) returns TagPaging|error {
        string resourcePath = string `/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a tag
    #
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get tags/[string tagId](map<string|string[]> headers = {}, *GetTagQueries queries) returns TagEntry|error {
        string resourcePath = string `/tags/${getEncodedUri(tagId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a tag
    #
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated tag 
    # + return - Successful response 
    resource isolated function put tags/[string tagId](TagBody payload, map<string|string[]> headers = {}, *UpdateTagQueries queries) returns TagEntry|error {
        string resourcePath = string `/tags/${getEncodedUri(tagId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get a network
    #
    # + networkId - The identifier of a network
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get networks/[string networkId](map<string|string[]> headers = {}, *GetNetworkQueries queries) returns PersonNetworkEntry|error {
        string resourcePath = string `/networks/${getEncodedUri(networkId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List shared links
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links(map<string|string[]> headers = {}, *ListSharedLinksQueries queries) returns SharedLinkPaging|error {
        string resourcePath = string `/shared-links`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a shared link to a file
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The nodeId to create a shared link for 
    # + return - Successful response 
    resource isolated function post shared\-links(SharedLinkBodyCreate payload, map<string|string[]> headers = {}, *CreateSharedLinkQueries queries) returns SharedLinkEntry|error {
        string resourcePath = string `/shared-links`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links/[string sharedId](map<string|string[]> headers = {}, *GetSharedLinkQueries queries) returns SharedLinkEntry|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Deletes a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete shared\-links/[string sharedId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get shared link content
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links/[string sharedId]/content(GetSharedLinkContentHeaders headers = {}, *GetSharedLinkContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List renditions for a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links/[string sharedId]/renditions(map<string|string[]> headers = {}) returns RenditionPaging|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get shared link rendition information
    #
    # + sharedId - The identifier of a shared link to a file
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links/[string sharedId]/renditions/[string renditionId](map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get shared link rendition content
    #
    # + sharedId - The identifier of a shared link to a file
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get shared\-links/[string sharedId]/renditions/[string renditionId]/content(GetSharedLinkRenditionContentHeaders headers = {}, *GetSharedLinkRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Email shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + payload - The shared link email to send 
    # + return - Successful response 
    resource isolated function post shared\-links/[string sharedId]/email(SharedLinkBodyEmail payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/email`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Check readiness and liveness of the repository
    #
    # + probeId - The name of the probe:
    # * -ready-
    # * -live-
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get probes/[string probeId](map<string|string[]> headers = {}) returns ProbeEntry|error {
        string resourcePath = string `/probes/${getEncodedUri(probeId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find nodes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get queries/nodes(map<string|string[]> headers = {}, *FindNodesQueries queries) returns NodePaging|error {
        string resourcePath = string `/queries/nodes`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find sites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get queries/sites(map<string|string[]> headers = {}, *FindSitesQueries queries) returns SitePaging|error {
        string resourcePath = string `/queries/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find people
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get queries/people(map<string|string[]> headers = {}, *FindPeopleQueries queries) returns PersonPaging|error {
        string resourcePath = string `/queries/people`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "orderBy": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get groups(map<string|string[]> headers = {}, *ListGroupsQueries queries) returns GroupPaging|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group to create 
    # + return - Successful response 
    resource isolated function post groups(GroupBodyCreate payload, map<string|string[]> headers = {}, *CreateGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get group details
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get groups/[string groupId](map<string|string[]> headers = {}, *GetGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update group details
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group information to update 
    # + return - Successful response 
    resource isolated function put groups/[string groupId](GroupBodyUpdate payload, map<string|string[]> headers = {}, *UpdateGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a group
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete groups/[string groupId](map<string|string[]> headers = {}, *DeleteGroupQueries queries) returns error? {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List memberships of a group
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get groups/[string groupId]/members(map<string|string[]> headers = {}, *ListGroupMembershipsQueries queries) returns GroupMemberPaging|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a group membership
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group membership to add (person or sub-group) 
    # + return - Successful response 
    resource isolated function post groups/[string groupId]/members(GroupMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateGroupMembershipQueries queries) returns GroupMemberEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete a group membership
    #
    # + groupId - The identifier of a group
    # + groupMemberId - The identifier of a person or group
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete groups/[string groupId]/members/[string groupMemberId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members/${getEncodedUri(groupMemberId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List audit applications
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get audit\-applications(map<string|string[]> headers = {}, *ListAuditAppsQueries queries) returns AuditAppPaging|error {
        string resourcePath = string `/audit-applications`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get audit application info
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get audit\-applications/[string auditApplicationId](map<string|string[]> headers = {}, *GetAuditAppQueries queries) returns AuditApp|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update audit application info
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The audit application to update 
    # + return - Successful response 
    resource isolated function put audit\-applications/[string auditApplicationId](AuditBodyUpdate payload, map<string|string[]> headers = {}, *UpdateAuditAppQueries queries) returns AuditApp|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List audit entries for an audit application
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get audit\-applications/[string auditApplicationId]/audit\-entries(map<string|string[]> headers = {}, *ListAuditEntriesForAuditAppQueries queries) returns AuditEntryPaging|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete audit entries for an audit application
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete audit\-applications/[string auditApplicationId]/audit\-entries(map<string|string[]> headers = {}, *DeleteAuditEntriesForAuditAppQueries queries) returns error? {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get audit entry
    #
    # + auditApplicationId - The identifier of an audit application
    # + auditEntryId - The identifier of an audit entry
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get audit\-applications/[string auditApplicationId]/audit\-entries/[string auditEntryId](map<string|string[]> headers = {}, *GetAuditEntryQueries queries) returns AuditEntryEntry|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries/${getEncodedUri(auditEntryId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete an audit entry
    #
    # + auditApplicationId - The identifier of an audit application
    # + auditEntryId - The identifier of an audit entry
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete audit\-applications/[string auditApplicationId]/audit\-entries/[string auditEntryId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries/${getEncodedUri(auditEntryId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List audit entries for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get nodes/[string nodeId]/audit\-entries(map<string|string[]> headers = {}, *ListAuditEntriesForNodeQueries queries) returns AuditEntryPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/audit-entries`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve list of available actions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get action\-definitions(map<string|string[]> headers = {}, *ListActionsQueries queries) returns ActionDefinitionList|error {
        string resourcePath = string `/action-definitions`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve the details of an action definition
    #
    # + actionDefinitionId - The identifier of an action definition
    # + headers - Headers to be sent with the request 
    # + return - Unexpected error 
    resource isolated function get action\-definitions/[string actionDefinitionId](map<string|string[]> headers = {}) returns ActionDefinitionEntry|error {
        string resourcePath = string `/action-definitions/${getEncodedUri(actionDefinitionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Execute an action
    #
    # + headers - Headers to be sent with the request 
    # + payload - Action execution details 
    # + return - Unexpected error 
    resource isolated function post action\-executions(ActionBodyExec payload, map<string|string[]> headers = {}) returns ActionExecResultEntry|error {
        string resourcePath = string `/action-executions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
