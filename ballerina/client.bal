// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# **Core API**
# 
# Provides access to the core features of Alfresco Content Services.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl) returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List comments
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listComments(string nodeId, map<string|string[]> headers = {}, *ListCommentsQueries queries) returns CommentPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a comment
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The comment text. Note that you can also provide a list of comments 
    # + return - Successful response 
    remote isolated function createComment(string nodeId, CommentBody payload, map<string|string[]> headers = {}, *CreateCommentQueries queries) returns CommentEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update a comment
    #
    # + nodeId - The identifier of a node
    # + commentId - The identifier of a comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The JSON representing the comment to be updated 
    # + return - Successful response 
    remote isolated function updateComment(string nodeId, string commentId, CommentBody payload, map<string|string[]> headers = {}, *UpdateCommentQueries queries) returns CommentEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments/${getEncodedUri(commentId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a comment
    #
    # + nodeId - The identifier of a node
    # + commentId - The identifier of a comment
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteComment(string nodeId, string commentId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/comments/${getEncodedUri(commentId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List ratings
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listRatings(string nodeId, map<string|string[]> headers = {}, *ListRatingsQueries queries) returns RatingPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a rating
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - For "myRating" the type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar 
    # + return - Successful response 
    remote isolated function createRating(string nodeId, RatingBody payload, map<string|string[]> headers = {}, *CreateRatingQueries queries) returns RatingEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a rating
    #
    # + nodeId - The identifier of a node
    # + ratingId - The identifier of a rating
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getRating(string nodeId, string ratingId, map<string|string[]> headers = {}, *GetRatingQueries queries) returns RatingEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings/${getEncodedUri(ratingId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a rating
    #
    # + nodeId - The identifier of a node
    # + ratingId - The identifier of a rating
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteRating(string nodeId, string ratingId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/ratings/${getEncodedUri(ratingId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List tags for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listTagsForNode(string nodeId, map<string|string[]> headers = {}, *ListTagsForNodeQueries queries) returns TagPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a tag for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new tag 
    # + return - Successful response 
    remote isolated function createTagForNode(string nodeId, TagBody payload, map<string|string[]> headers = {}, *CreateTagForNodeQueries queries) returns TagEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete a tag from a node
    #
    # + nodeId - The identifier of a node
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteTagFromNode(string nodeId, string tagId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/tags/${getEncodedUri(tagId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a node
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getNode(string nodeId, map<string|string[]> headers = {}, *GetNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The node information to update 
    # + return - Successful response 
    remote isolated function updateNode(string nodeId, NodeBodyUpdate payload, map<string|string[]> headers = {}, *UpdateNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteNode(string nodeId, map<string|string[]> headers = {}, *DeleteNodeQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List node children
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listNodeChildren(string nodeId, map<string|string[]> headers = {}, *ListNodeChildrenQueries queries) returns NodeChildAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/children`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a node
    #
    # + nodeId - The identifier of a node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The node information to create 
    # + return - Successful response 
    remote isolated function createNode(string nodeId, NodeBodyCreate payload, map<string|string[]> headers = {}, *CreateNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/children`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Copy a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId and, optionally, a new name which should include the file extension 
    # + return - Successful response 
    remote isolated function copyNode(string nodeId, NodeBodyCopy payload, map<string|string[]> headers = {}, *CopyNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/copy`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Lock a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Lock details 
    # + return - Successful response 
    remote isolated function lockNode(string nodeId, NodeBodyLock payload, map<string|string[]> headers = {}, *LockNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/lock`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unlock a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function unlockNode(string nodeId, map<string|string[]> headers = {}, *UnlockNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/unlock`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Move a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId and, optionally, a new name which should include the file extension 
    # + return - Successful response 
    remote isolated function moveNode(string nodeId, NodeBodyMove payload, map<string|string[]> headers = {}, *MoveNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/move`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getNodeContent(string nodeId, GetNodeContentHeaders headers = {}, *GetNodeContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The binary content 
    # + return - Successful response 
    remote isolated function updateNodeContent(string nodeId, byte[] payload, map<string|string[]> headers = {}, *UpdateNodeContentQueries queries) returns NodeEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/content`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List renditions
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listRenditions(string nodeId, map<string|string[]> headers = {}, *ListRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create rendition
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + payload - The rendition "id" 
    # + return - Request accepted 
    remote isolated function createRendition(string nodeId, RenditionBodyCreate payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get rendition information
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getRendition(string nodeId, string renditionId, map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getRenditionContent(string nodeId, string renditionId, GetRenditionContentHeaders headers = {}, *GetRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List secondary children
    #
    # + nodeId - The identifier of a parent node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSecondaryChildren(string nodeId, map<string|string[]> headers = {}, *ListSecondaryChildrenQueries queries) returns NodeChildAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create secondary child
    #
    # + nodeId - The identifier of a parent node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The child node id and assoc type 
    # + return - Successful response 
    remote isolated function createSecondaryChildAssociation(string nodeId, ChildAssociationBody payload, map<string|string[]> headers = {}, *CreateSecondaryChildAssociationQueries queries) returns ChildAssociationEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete secondary child or children
    #
    # + nodeId - The identifier of a parent node
    # + childId - The identifier of a child node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSecondaryChildAssociation(string nodeId, string childId, map<string|string[]> headers = {}, *DeleteSecondaryChildAssociationQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/secondary-children/${getEncodedUri(childId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List parents
    #
    # + nodeId - The identifier of a child node. You can also use one of these well-known aliases:
    # * -my-
    # * -shared-
    # * -root-
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listParents(string nodeId, map<string|string[]> headers = {}, *ListParentsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/parents`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List target associations
    #
    # + nodeId - The identifier of a source node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listTargetAssociations(string nodeId, map<string|string[]> headers = {}, *ListTargetAssociationsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create node association
    #
    # + nodeId - The identifier of a source node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The target node id and assoc type 
    # + return - Successful response 
    remote isolated function createAssociation(string nodeId, AssociationBody payload, map<string|string[]> headers = {}, *CreateAssociationQueries queries) returns AssociationEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete node association(s)
    #
    # + nodeId - The identifier of a source node
    # + targetId - The identifier of a target node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteAssociation(string nodeId, string targetId, map<string|string[]> headers = {}, *DeleteAssociationQueries queries) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/targets/${getEncodedUri(targetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List source associations
    #
    # + nodeId - The identifier of a target node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSourceAssociations(string nodeId, map<string|string[]> headers = {}, *ListSourceAssociationsQueries queries) returns NodeAssociationPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/sources`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List version history
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listVersionHistory(string nodeId, map<string|string[]> headers = {}, *ListVersionHistoryQueries queries) returns VersionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get version information
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getVersion(string nodeId, string versionId, map<string|string[]> headers = {}) returns VersionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteVersion(string nodeId, string versionId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get version content
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getVersionContent(string nodeId, string versionId, GetVersionContentHeaders headers = {}, *GetVersionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Revert a version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Optionally, specify a version comment and whether this should be a major version, or not 
    # + return - Successful response 
    remote isolated function revertVersion(string nodeId, string versionId, RevertBody payload, map<string|string[]> headers = {}, *RevertVersionQueries queries) returns VersionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/revert`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List renditions for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listVersionRenditions(string nodeId, string versionId, map<string|string[]> headers = {}, *ListVersionRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create rendition for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + headers - Headers to be sent with the request 
    # + payload - The rendition "id" 
    # + return - Request accepted 
    remote isolated function createVersionRendition(string nodeId, string versionId, RenditionBodyCreate payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get rendition information for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getVersionRendition(string nodeId, string versionId, string renditionId, map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content for a file version
    #
    # + nodeId - The identifier of a node
    # + versionId - The identifier of a version, ie. version label, within the version history of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getVersionRenditionContent(string nodeId, string versionId, string renditionId, GetVersionRenditionContentHeaders headers = {}, *GetVersionRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/versions/${getEncodedUri(versionId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieve actions for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Unexpected error 
    remote isolated function nodeActions(string nodeId, map<string|string[]> headers = {}, *NodeActionsQueries queries) returns ActionDefinitionList|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/action-definitions`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List deleted nodes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listDeletedNodes(map<string|string[]> headers = {}, *ListDeletedNodesQueries queries) returns DeletedNodesPaging|error {
        string resourcePath = string `/deleted-nodes`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getDeletedNode(string nodeId, map<string|string[]> headers = {}, *GetDeletedNodeQueries queries) returns DeletedNodeEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteDeletedNode(string nodeId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get deleted node content
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getDeletedNodeContent(string nodeId, GetDeletedNodeContentHeaders headers = {}, *GetDeletedNodeContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Restore a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The targetParentId if the node is restored to a new location 
    # + return - Successful response 
    remote isolated function restoreDeletedNode(string nodeId, DeletedNodeBodyRestore payload, map<string|string[]> headers = {}, *RestoreDeletedNodeQueries queries) returns NodeEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/restore`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List renditions for a deleted node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listDeletedNodeRenditions(string nodeId, map<string|string[]> headers = {}, *ListDeletedNodeRenditionsQueries queries) returns RenditionPaging|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition information for a deleted node
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getArchivedNodeRendition(string nodeId, string renditionId, map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get rendition content of a deleted node
    #
    # + nodeId - The identifier of a node
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getArchivedNodeRenditionContent(string nodeId, string renditionId, GetArchivedNodeRenditionContentHeaders headers = {}, *GetArchivedNodeRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/deleted-nodes/${getEncodedUri(nodeId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a new download
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The nodeIds the content of which will be zipped, which zip will be set as the content of our download node 
    # + return - The request to create a download node was accepted 
    remote isolated function createDownload(DownloadBodyCreate payload, map<string|string[]> headers = {}, *CreateDownloadQueries queries) returns DownloadEntry|error {
        string resourcePath = string `/downloads`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a download
    #
    # + downloadId - The identifier of a download node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Download node information 
    remote isolated function getDownload(string downloadId, map<string|string[]> headers = {}, *GetDownloadQueries queries) returns DownloadEntry|error {
        string resourcePath = string `/downloads/${getEncodedUri(downloadId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Cancel a download
    #
    # + downloadId - The identifier of a download node
    # + headers - Headers to be sent with the request 
    # + return - The request to cancel a download was accepted 
    remote isolated function cancelDownload(string downloadId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/downloads/${getEncodedUri(downloadId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List people
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listPeople(map<string|string[]> headers = {}, *ListPeopleQueries queries) returns PersonPaging|error {
        string resourcePath = string `/people`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create person
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person details 
    # + return - Successful response 
    remote isolated function createPerson(PersonBodyCreate payload, map<string|string[]> headers = {}, *CreatePersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a person
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getPerson(string personId, map<string|string[]> headers = {}, *GetPersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update person
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person details 
    # + return - Successful response 
    remote isolated function updatePerson(string personId, PersonBodyUpdate payload, map<string|string[]> headers = {}, *UpdatePersonQueries queries) returns PersonEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List activities
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listActivitiesForPerson(string personId, map<string|string[]> headers = {}, *ListActivitiesForPersonQueries queries) returns ActivityPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/activities`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List favorite sites
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    remote isolated function listFavoriteSitesForPerson(string personId, map<string|string[]> headers = {}, *ListFavoriteSitesForPersonQueries queries) returns SitePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site favorite
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The id of the site to favorite 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    remote isolated function createSiteFavorite(string personId, FavoriteSiteBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteFavoriteQueries queries) returns FavoriteSiteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a favorite site
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    remote isolated function getFavoriteSite(string personId, string siteId, map<string|string[]> headers = {}, *GetFavoriteSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a site favorite
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    # 
    # # Deprecated
    @deprecated
    remote isolated function deleteSiteFavorite(string personId, string siteId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorite-sites/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List favorites
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listFavorites(string personId, map<string|string[]> headers = {}, *ListFavoritesQueries queries) returns FavoritePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a favorite
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - An object identifying the entity to be favorited 
    # + return - Successful response 
    remote isolated function createFavorite(string personId, FavoriteBodyCreate payload, map<string|string[]> headers = {}, *CreateFavoriteQueries queries) returns FavoriteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a favorite
    #
    # + personId - The identifier of a person
    # + favoriteId - The identifier of a favorite
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getFavorite(string personId, string favoriteId, map<string|string[]> headers = {}, *GetFavoriteQueries queries) returns FavoriteEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites/${getEncodedUri(favoriteId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a favorite
    #
    # + personId - The identifier of a person
    # + favoriteId - The identifier of a favorite
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteFavorite(string personId, string favoriteId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/favorites/${getEncodedUri(favoriteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List network membership
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listNetworksForPerson(string personId, map<string|string[]> headers = {}, *ListNetworksForPersonQueries queries) returns PersonNetworkPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/networks`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get network information
    #
    # + personId - The identifier of a person
    # + networkId - The identifier of a network
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getNetworkForPerson(string personId, string networkId, map<string|string[]> headers = {}, *GetNetworkForPersonQueries queries) returns PersonNetworkEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/networks/${getEncodedUri(networkId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List preferences
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listPreferences(string personId, map<string|string[]> headers = {}, *ListPreferencesQueries queries) returns PreferencePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/preferences`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a preference
    #
    # + personId - The identifier of a person
    # + preferenceName - The name of the preference
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getPreference(string personId, string preferenceName, map<string|string[]> headers = {}, *GetPreferenceQueries queries) returns PreferenceEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/preferences/${getEncodedUri(preferenceName)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List site membership requests
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSiteMembershipRequestsForPerson(string personId, map<string|string[]> headers = {}, *ListSiteMembershipRequestsForPersonQueries queries) returns SiteMembershipRequestPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership request
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Site membership request details 
    # + return - Successful response 
    remote isolated function createSiteMembershipRequestForPerson(string personId, SiteMembershipRequestBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteMembershipRequestForPerson(string personId, string siteId, map<string|string[]> headers = {}, *GetSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The new message to display 
    # + return - Successful response 
    remote isolated function updateSiteMembershipRequestForPerson(string personId, string siteId, SiteMembershipRequestBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteMembershipRequestForPersonQueries queries) returns SiteMembershipRequestEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site membership request
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSiteMembershipRequestForPerson(string personId, string siteId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/site-membership-requests/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List site memberships
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSiteMembershipsForPerson(string personId, map<string|string[]> headers = {}, *ListSiteMembershipsForPersonQueries queries) returns SiteRolePaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a site membership
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteMembershipForPerson(string personId, string siteId, map<string|string[]> headers = {}) returns SiteRoleEntry|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites/${getEncodedUri(siteId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a site membership
    #
    # + personId - The identifier of a person
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSiteMembershipForPerson(string personId, string siteId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/sites/${getEncodedUri(siteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List group memberships
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listGroupMembershipsForPerson(string personId, map<string|string[]> headers = {}, *ListGroupMembershipsForPersonQueries queries) returns GroupPaging|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/groups`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Request password reset
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The client name to send email with app-specific url 
    # + return - Successful response or even when the **personId** does not exist or the user is disabled by an Administrator 
    remote isolated function requestPasswordReset(string personId, ClientBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/request-password-reset`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reset password
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The reset password details 
    # + return - Successful response or even when no workflow instance is found with the given **id** or the workflow instance is invalid (already been used or expired) or the given **personId** does not match the person's id requesting the password reset or the given workflow **key** does not match the recovered key 
    remote isolated function resetPassword(string personId, PasswordResetBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/reset-password`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getAvatarImage(string personId, GetAvatarImageHeaders headers = {}, *GetAvatarImageQueries queries) returns byte[]|error {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + payload - The binary content 
    # + return - Successful response 
    remote isolated function updateAvatarImage(string personId, byte[] payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete avatar image
    #
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteAvatarImage(string personId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/people/${getEncodedUri(personId)}/avatar`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List sites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSites(map<string|string[]> headers = {}, *ListSitesQueries queries) returns SitePaging|error {
        string resourcePath = string `/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The site details 
    # + return - Successful response 
    remote isolated function createSite(SiteBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSite(string siteId, map<string|string[]> headers = {}, *GetSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"relations": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The site information to update 
    # + return - Successful response 
    remote isolated function updateSite(string siteId, SiteBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteQueries queries) returns SiteEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSite(string siteId, map<string|string[]> headers = {}, *DeleteSiteQueries queries) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List site containers
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSiteContainers(string siteId, map<string|string[]> headers = {}, *ListSiteContainersQueries queries) returns SiteContainerPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/containers`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a site container
    #
    # + siteId - The identifier of a site
    # + containerId - The unique identifier of a site container
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteContainer(string siteId, string containerId, map<string|string[]> headers = {}, *GetSiteContainerQueries queries) returns SiteContainerEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/containers/${getEncodedUri(containerId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get site membership requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteMembershipRequests(map<string|string[]> headers = {}, *GetSiteMembershipRequestsQueries queries) returns SiteMembershipRequestWithPersonPaging|error {
        string resourcePath = string `/site-membership-requests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Approve a site membership request
    #
    # + siteId - The identifier of a site
    # + inviteeId - The invitee user name
    # + headers - Headers to be sent with the request 
    # + payload - Accepting a request to join, optionally, allows assignment of a role to the user 
    # + return - Successful response 
    remote isolated function approveSiteMembershipRequest(string siteId, string inviteeId, SiteMembershipApprovalBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/site-membership-requests/${getEncodedUri(inviteeId)}/approve`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reject a site membership request
    #
    # + siteId - The identifier of a site
    # + inviteeId - The invitee user name
    # + headers - Headers to be sent with the request 
    # + payload - Rejecting a request to join, optionally, allows the inclusion of comment 
    # + return - Successful response 
    remote isolated function rejectSiteMembershipRequest(string siteId, string inviteeId, SiteMembershipRejectionBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/site-membership-requests/${getEncodedUri(inviteeId)}/reject`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List site memberships
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSiteMemberships(string siteId, map<string|string[]> headers = {}, *ListSiteMembershipsQueries queries) returns SiteMemberPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The person to add and their role 
    # + return - Successful response 
    remote isolated function createSiteMembership(string siteId, SiteMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteMembership(string siteId, string personId, map<string|string[]> headers = {}, *GetSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The persons new role 
    # + return - Successful response 
    remote isolated function updateSiteMembership(string siteId, string personId, SiteMembershipBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteMembershipQueries queries) returns SiteMemberEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a site membership
    #
    # + siteId - The identifier of a site
    # + personId - The identifier of a person
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSiteMembership(string siteId, string personId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/members/${getEncodedUri(personId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List group membership for site
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSiteGroups(string siteId, map<string|string[]> headers = {}, *ListSiteGroupsQueries queries) returns SiteGroupPaging|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a site membership for group
    #
    # + siteId - The identifier of a site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group to add and their role 
    # + return - Successful response 
    remote isolated function createSiteGroupMembership(string siteId, SiteMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get information about site membership of group
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSiteGroupMembership(string siteId, string groupId, map<string|string[]> headers = {}, *GetSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update site membership of group
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The groupId new role 
    # + return - Successful response 
    remote isolated function updateSiteGroupMembership(string siteId, string groupId, SiteMembershipBodyUpdate payload, map<string|string[]> headers = {}, *UpdateSiteGroupMembershipQueries queries) returns SiteGroupEntry|error {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a group membership for site
    #
    # + siteId - The identifier of a site
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSiteGroupMembership(string siteId, string groupId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/sites/${getEncodedUri(siteId)}/group-members/${getEncodedUri(groupId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List tags
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listTags(map<string|string[]> headers = {}, *ListTagsQueries queries) returns TagPaging|error {
        string resourcePath = string `/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a tag
    #
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getTag(string tagId, map<string|string[]> headers = {}, *GetTagQueries queries) returns TagEntry|error {
        string resourcePath = string `/tags/${getEncodedUri(tagId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update a tag
    #
    # + tagId - The identifier of a tag
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The updated tag 
    # + return - Successful response 
    remote isolated function updateTag(string tagId, TagBody payload, map<string|string[]> headers = {}, *UpdateTagQueries queries) returns TagEntry|error {
        string resourcePath = string `/tags/${getEncodedUri(tagId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get a network
    #
    # + networkId - The identifier of a network
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getNetwork(string networkId, map<string|string[]> headers = {}, *GetNetworkQueries queries) returns PersonNetworkEntry|error {
        string resourcePath = string `/networks/${getEncodedUri(networkId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List shared links
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listSharedLinks(map<string|string[]> headers = {}, *ListSharedLinksQueries queries) returns SharedLinkPaging|error {
        string resourcePath = string `/shared-links`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a shared link to a file
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The nodeId to create a shared link for 
    # + return - Successful response 
    remote isolated function createSharedLink(SharedLinkBodyCreate payload, map<string|string[]> headers = {}, *CreateSharedLinkQueries queries) returns SharedLinkEntry|error {
        string resourcePath = string `/shared-links`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSharedLink(string sharedId, map<string|string[]> headers = {}, *GetSharedLinkQueries queries) returns SharedLinkEntry|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Deletes a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteSharedLink(string sharedId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get shared link content
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSharedLinkContent(string sharedId, GetSharedLinkContentHeaders headers = {}, *GetSharedLinkContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List renditions for a shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function listSharedLinkRenditions(string sharedId, map<string|string[]> headers = {}) returns RenditionPaging|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get shared link rendition information
    #
    # + sharedId - The identifier of a shared link to a file
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getSharedLinkRendition(string sharedId, string renditionId, map<string|string[]> headers = {}) returns RenditionEntry|error {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions/${getEncodedUri(renditionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get shared link rendition content
    #
    # + sharedId - The identifier of a shared link to a file
    # + renditionId - The name of a thumbnail rendition, for example *doclib*, or *pdf*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getSharedLinkRenditionContent(string sharedId, string renditionId, GetSharedLinkRenditionContentHeaders headers = {}, *GetSharedLinkRenditionContentQueries queries) returns byte[]|error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/renditions/${getEncodedUri(renditionId)}/content`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Email shared link
    #
    # + sharedId - The identifier of a shared link to a file
    # + headers - Headers to be sent with the request 
    # + payload - The shared link email to send 
    # + return - Successful response 
    remote isolated function emailSharedLink(string sharedId, SharedLinkBodyEmail payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/shared-links/${getEncodedUri(sharedId)}/email`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Check readiness and liveness of the repository
    #
    # + probeId - The name of the probe:
    # * -ready-
    # * -live-
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function getProbe(string probeId, map<string|string[]> headers = {}) returns ProbeEntry|error {
        string resourcePath = string `/probes/${getEncodedUri(probeId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find nodes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function findNodes(map<string|string[]> headers = {}, *FindNodesQueries queries) returns NodePaging|error {
        string resourcePath = string `/queries/nodes`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find sites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function findSites(map<string|string[]> headers = {}, *FindSitesQueries queries) returns SitePaging|error {
        string resourcePath = string `/queries/sites`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find people
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function findPeople(map<string|string[]> headers = {}, *FindPeopleQueries queries) returns PersonPaging|error {
        string resourcePath = string `/queries/people`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "orderBy": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listGroups(map<string|string[]> headers = {}, *ListGroupsQueries queries) returns GroupPaging|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group to create 
    # + return - Successful response 
    remote isolated function createGroup(GroupBodyCreate payload, map<string|string[]> headers = {}, *CreateGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get group details
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getGroup(string groupId, map<string|string[]> headers = {}, *GetGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update group details
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group information to update 
    # + return - Successful response 
    remote isolated function updateGroup(string groupId, GroupBodyUpdate payload, map<string|string[]> headers = {}, *UpdateGroupQueries queries) returns GroupEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<Encoding> queryParamEncoding = {"include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete a group
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteGroup(string groupId, map<string|string[]> headers = {}, *DeleteGroupQueries queries) returns error? {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List memberships of a group
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listGroupMemberships(string groupId, map<string|string[]> headers = {}, *ListGroupMembershipsQueries queries) returns GroupMemberPaging|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a group membership
    #
    # + groupId - The identifier of a group
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The group membership to add (person or sub-group) 
    # + return - Successful response 
    remote isolated function createGroupMembership(string groupId, GroupMembershipBodyCreate payload, map<string|string[]> headers = {}, *CreateGroupMembershipQueries queries) returns GroupMemberEntry|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete a group membership
    #
    # + groupId - The identifier of a group
    # + groupMemberId - The identifier of a person or group
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteGroupMembership(string groupId, string groupMemberId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members/${getEncodedUri(groupMemberId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List audit applications
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listAuditApps(map<string|string[]> headers = {}, *ListAuditAppsQueries queries) returns AuditAppPaging|error {
        string resourcePath = string `/audit-applications`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get audit application info
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getAuditApp(string auditApplicationId, map<string|string[]> headers = {}, *GetAuditAppQueries queries) returns AuditApp|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "include": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update audit application info
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The audit application to update 
    # + return - Successful response 
    remote isolated function updateAuditApp(string auditApplicationId, AuditBodyUpdate payload, map<string|string[]> headers = {}, *UpdateAuditAppQueries queries) returns AuditApp|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List audit entries for an audit application
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listAuditEntriesForAuditApp(string auditApplicationId, map<string|string[]> headers = {}, *ListAuditEntriesForAuditAppQueries queries) returns AuditEntryPaging|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete audit entries for an audit application
    #
    # + auditApplicationId - The identifier of an audit application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteAuditEntriesForAuditApp(string auditApplicationId, map<string|string[]> headers = {}, *DeleteAuditEntriesForAuditAppQueries queries) returns error? {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get audit entry
    #
    # + auditApplicationId - The identifier of an audit application
    # + auditEntryId - The identifier of an audit entry
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function getAuditEntry(string auditApplicationId, string auditEntryId, map<string|string[]> headers = {}, *GetAuditEntryQueries queries) returns AuditEntryEntry|error {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries/${getEncodedUri(auditEntryId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Permanently delete an audit entry
    #
    # + auditApplicationId - The identifier of an audit application
    # + auditEntryId - The identifier of an audit entry
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    remote isolated function deleteAuditEntry(string auditApplicationId, string auditEntryId, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/audit-applications/${getEncodedUri(auditApplicationId)}/audit-entries/${getEncodedUri(auditEntryId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List audit entries for a node
    #
    # + nodeId - The identifier of a node
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listAuditEntriesForNode(string nodeId, map<string|string[]> headers = {}, *ListAuditEntriesForNodeQueries queries) returns AuditEntryPaging|error {
        string resourcePath = string `/nodes/${getEncodedUri(nodeId)}/audit-entries`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "include": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve list of available actions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    remote isolated function listActions(map<string|string[]> headers = {}, *ListActionsQueries queries) returns ActionDefinitionList|error {
        string resourcePath = string `/action-definitions`;
        map<Encoding> queryParamEncoding = {"orderBy": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve the details of an action definition
    #
    # + actionDefinitionId - The identifier of an action definition
    # + headers - Headers to be sent with the request 
    # + return - Unexpected error 
    remote isolated function actionDetails(string actionDefinitionId, map<string|string[]> headers = {}) returns ActionDefinitionEntry|error {
        string resourcePath = string `/action-definitions/${getEncodedUri(actionDefinitionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Execute an action
    #
    # + headers - Headers to be sent with the request 
    # + payload - Action execution details 
    # + return - Unexpected error 
    remote isolated function actionExec(ActionBodyExec payload, map<string|string[]> headers = {}) returns ActionExecResultEntry|error {
        string resourcePath = string `/action-executions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
